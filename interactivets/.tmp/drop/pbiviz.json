{"visual":{"name":"interactivets","displayName":"Interactive Time-Series Plot","guid":"interactivetsBB3C2FD6EC3D483DB7CA402F922AA628","visualClassName":"Visual","version":"1.0.0","description":"Interactive time-series plot implemented using functions from the 'modeltime' package","supportUrl":"https://medium.com/@lucazav","gitHubUrl":"https://github.com/lucazav/power-bi-time-series-custom-visual"},"author":{"name":"Luca Zavarella","email":"lucazavarella@email.me"},"apiVersion":"3.8.0","style":"style/visual.less","stringResources":{},"capabilities":{"dataRoles":[{"displayName":"Date Variable","description":"Date variable associated to the time-series to plot","kind":"GroupingOrMeasure","name":"index"},{"displayName":"Value Variable","description":"Numeric variable of the time-series to plot","kind":"GroupingOrMeasure","name":"value"},{"displayName":"Value Type Variable","description":"String variable indicating the nature of the value. It assumes label 'actual' if the corresponding value is an actual value for the time-series. It assumes label 'prediction' if the corresponding value is a prediction for the time-series.","kind":"GroupingOrMeasure","name":"value_type"},{"displayName":"Confidence Low Variable","description":"Numeric variable associated to the low value of the confidence bar to plot","kind":"GroupingOrMeasure","name":"conf_lo"},{"displayName":"Confidence High Variable","description":"Numeric variable associated to the high value of the confidence bar to plot","kind":"GroupingOrMeasure","name":"conf_hi"},{"displayName":"Model ID","description":"Optional integer variable used to identify observations of different models in the same dataset","kind":"GroupingOrMeasure","name":"model_id"},{"displayName":"Model Description","description":"Optional string variable used as model label associated to the Model ID","kind":"GroupingOrMeasure","name":"model_descr"}],"dataViewMappings":[{"scriptResult":{"dataInput":{"table":{"rows":{"select":[{"for":{"in":"index"}},{"for":{"in":"value"}},{"for":{"in":"value_type"}},{"for":{"in":"conf_lo"}},{"for":{"in":"conf_hi"}},{"for":{"in":"model_id"}},{"for":{"in":"model_descr"}}],"dataReductionAlgorithm":{"top":{}}}}},"script":{"scriptProviderDefault":"R","scriptOutputType":"html","source":{"objectName":"rcv_script","propertyName":"source"},"provider":{"objectName":"rcv_script","propertyName":"provider"},"scriptSourceDefault":"############### Utility functions ###############\nlibraryRequireInstall = function(packageName, ...)\n{\n  if(!require(packageName, character.only = TRUE)) \n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\", sep=\"\"))\n}\n\nlibraryRequireInstall(\"xml2\")\nlibraryRequireInstall(\"htmlwidgets\")\n\ninternalSaveWidget <- function(widget, fname)\n{\n  tempFname = paste(fname, \".tmp\", sep=\"\")\n  htmlwidgets::saveWidget(widget, file = tempFname, selfcontained = FALSE)\n  FlattenHTML(tempFname, fname)\n}\n\nFlattenHTML <- function(fnameIn, fnameOut)\n{\n  # Read and parse HTML file\n  # Embed all js and css files into one unified file\n  \n  if(!file.exists(fnameIn))\n    return(FALSE)\n  \n  dir = dirname(fnameIn)\n  html = read_html(fnameIn, useInternal = TRUE)\n  top = xml_root(html)\n  \n  # extract all <script> tags with src value\n  srcNode=xml_find_all(top, '//script[@src]')\n  for (node in srcNode)\n  {\n    b = xml_attrs(node)\n    fname = file.path(dir, b['src'])\n    alternateSrc = FindSrcReplacement(fname)\n    if (!is.null(alternateSrc))\n    {\n      s = alternateSrc\n      names(s) = 'src'\n      newNode = xml_new_root(\"script\")\n      xml_set_attrs(newNode, s)\n      xml_replace(node, newNode)\n    }else{\n      str=ReadFileForEmbedding(fname);\n      if (!is.null(str))\n      {      \n        newNode = xml_new_root(\"script\",str)\n        xml_set_attrs( newNode, c( type = \"text/javascript\") )\n        xml_replace(node, newNode)\n      }\n    }\n  }\n  \n  # extract all <link> tags with src value\n  linkNode=xml_find_all(top, '//link[@href]')\n  for (node in linkNode)\n  {\n    b = xml_attrs(node)\n    fname = file.path(dir, b['href'])\n    str = ReadFileForEmbedding(fname, FALSE);\n    if (!is.null(str))\n    {\n      newNode = xml_new_root(\"style\", str)\n      xml_replace(node, newNode)\n    }\n  }\n  \n  write_xml(html, file = fnameOut)\n  return(TRUE)\n}\n\nReadFileForEmbedding <- function(fname, addCdata = TRUE)\n{\n  data = ReadFullFile(fname)\n  if (is.null(data))\n    return(NULL)\n\n  str = paste(data, collapse ='\\n')\n  if (addCdata) {\n    str = paste(cbind('// <![CDATA[', str,'// ]]>'), collapse ='\\n')\n  }\n  return(str)\n}\n\nReadFullFile <- function(fname)\n{\n  if(!file.exists(fname))\n    return(NULL)\n  \n  con = file(fname, open = \"r\")\n  data = readLines(con)\n  close(con)\n  return(data)\n}\n\nFindSrcReplacement <- function(str)\n{\n  # finds reference to 'plotly' js and replaces with a version from CDN\n  # This allows the HTML to be smaller, since this script is not fully embedded in it\n  str <- iconv(str, to=\"UTF-8\")\n  pattern = \"plotly-(\\\\w.+)/plotly-latest.min.js\"\n  match1=regexpr(pattern, str)\n  attr(match1, 'useBytes') <- FALSE\n  strMatch=regmatches(str, match1, invert = FALSE)\n  if (length(strMatch) == 0) return(NULL)\n  \n  pattern2 = \"-(\\\\d.+)/\"\n  match2 = regexpr(pattern2, strMatch[1])\n  attr(match2, 'useBytes') <- FALSE\n  strmatch = regmatches(strMatch[1], match2)\n  if (length(strmatch) == 0) return(NULL)\n  \n  # CDN url is https://cdn.plot.ly/plotly-<Version>.js\n  # This matches the specific version used in the plotly package used.\n  verstr = substr(strmatch, 2, nchar(strmatch)-1)\n  str = paste('https://cdn.plot.ly/plotly-', verstr,'.min.js', sep='')\n  return(str)\n}\n\nReadFullFileReplaceString <- function(fnameIn, fnameOut, sourceString,targetString) {\n  # Replaces texts in file\n  # This makes it possible to replace e.g. paddings in the generated html widget code\n  if(!file.exists(fnameIn))\n    return(NULL)\n  tx  <- readLines(fnameIn,encoding = \"UTF-8\")\n  tx2  <- gsub(pattern = sourceString, replace = targetString, x = tx)\n  writeLines(tx2, con = fnameOut)\n}\n#################################################\n\n\n############### Library Declarations ###############\nlibraryRequireInstall(\"ggplot2\");\nlibraryRequireInstall(\"plotly\");\nlibraryRequireInstall(\"dplyr\");\n####################################################\n\n################### Actual code ####################\n\n#' Interactive Plotting for One or More Time Series\n#'\n#' A workhorse time-series plotting function that generates interactive `plotly` plots,\n#' consolidates 20+ lines of `ggplot2` code, and scales well to many time series.\n#'\n#'\n#' @param .data A `tibble` or `data.frame` with a time-based column\n#' @param .date_var A column containing either date or date-time values\n#' @param .value A column containing numeric values\n#' @param .color_var A categorical column that can be used to change the\n#'  line color\n#' @param .facet_vars One or more grouping columns that broken out into `ggplot2` facets.\n#'  These can be selected using `tidyselect()` helpers (e.g `contains()`).\n#' @param .facet_ncol Number of facet columns.\n#' @param .facet_scales Control facet x & y-axis ranges.\n#'  Options include \"fixed\", \"free\", \"free_y\", \"free_x\"\n#' @param .facet_dir The direction of faceting (\"h\" for horizontal, \"v\" for vertical). Default is \"h\".\n#' @param .facet_collapse Multiple facets included on one facet strip instead of\n#'  multiple facet strips.\n#' @param .facet_collapse_sep The separator used for collapsing facets.\n#' @param .line_color Line color. Overrided if `.color_var` is specified.\n#' @param .line_size Line size.\n#' @param .line_type Line type.\n#' @param .line_alpha Line alpha (opacity). Range: (0, 1).\n#' @param .y_intercept Value for a y-intercept on the plot\n#' @param .y_intercept_color Color for the y-intercept\n#' @param .smooth Logical - Whether or not to include a trendline smoother.\n#'  Uses See [smooth_vec()] to apply a LOESS smoother.\n#' @param .smooth_period Number of observations to include in the Loess Smoother.\n#'  Set to \"auto\" by default, which uses `tk_get_trend()`\n#'  to determine a logical trend cycle.\n#' @param .smooth_message Logical.\n#'  Whether or not to return the trend selected as a message.\n#'  Useful for those that want to see what `.smooth_period` was selected.\n#' @param .smooth_span Percentage of observations to include in the Loess Smoother.\n#'  You can use either period or span. See [smooth_vec()].\n#' @param .smooth_degree Flexibility of Loess Polynomial.\n#'  Either 0, 1, 2 (0 = lest flexible, 2 = more flexible).\n#' @param .smooth_color Smoother line color\n#' @param .smooth_size Smoother line size\n#' @param .smooth_alpha Smoother alpha (opacity). Range: (0, 1).\n#' @param .legend_show Toggles on/off the Legend\n#' @param .title Title for the plot\n#' @param .x_lab X-axis label for the plot\n#' @param .y_lab Y-axis label for the plot\n#' @param .color_lab Legend label if a `color_var` is used.\n#' @param .interactive Returns either a static (`ggplot2`) visualization or an interactive (`plotly`) visualization\n#' @param .plotly_slider If TRUE, returns a plotly date range slider.\n#'\n#' @return A static `ggplot2` plot or an interactive `plotly` plot\n#'\n#' @details\n#'\n#' `plot_time_series()` is a scalable function that works with both _ungrouped_ and _grouped_\n#' `data.frame` objects (and `tibbles`!).\n#'\n#' __Interactive by Default__\n#'\n#' `plot_time_series()` is built for exploration using:\n#'\n#'  - __Interactive Plots:__ `plotly` (default) - Great for exploring!\n#'  - __Static Plots:__ `ggplot2` (set `.interactive = FALSE`) - Great for PDF Reports\n#'\n#' By default, an interactive `plotly` visualization is returned.\n#'\n#' __Scalable with Facets & Dplyr Groups__\n#'\n#' `plot_time_series()` returns multiple time series plots using `ggplot2` facets:\n#'\n#'  - `group_by()` - If groups are detected, multiple facets are returned\n#'  - `plot_time_series(.facet_vars)` - You can manually supply facets as well.\n#'\n#' __Can Transform Values just like ggplot__\n#'\n#' The `.values` argument accepts transformations just like `ggplot2`.\n#' For example, if you want to take the log of sales you can use\n#' a call like `plot_time_series(date, log(sales))` and the log transformation\n#' will be applied.\n#'\n#' __Smoother Period / Span Calculation__\n#'\n#' The `.smooth = TRUE` option returns a smoother that is calculated based on either:\n#'\n#' 1. A `.smooth_period`: Number of observations\n#' 2. A `.smooth_span`: A percentage of observations\n#'\n#' By default, the `.smooth_period` is automatically calculated using 75% of the observertions.\n#' This is the same as `geom_smooth(method = \"loess\", span = 0.75)`.\n#'\n#' A user can specify a time-based window (e.g. `.smooth_period = \"1 year\"`)\n#' or a numeric value (e.g. `smooth_period = 365`).\n#'\n#' Time-based windows return the median number of observations in a window using `tk_get_trend()`.\n#'\n#'\n#'\n#' @examples\n#'\n#' library(tidyverse)\n#' library(tidyquant)\n#' library(lubridate)\n#' library(timetk)\n#'\n#' # Works with individual time series\n#' FANG %>%\n#'     filter(symbol == \"FB\") %>%\n#'     plot_time_series(date, adjusted, .interactive = FALSE)\n#'\n#' # Works with groups\n#' FANG %>%\n#'     group_by(symbol) %>%\n#'     plot_time_series(date, adjusted,\n#'                      .facet_ncol  = 2,     # 2-column layout\n#'                      .interactive = FALSE)\n#'\n#' # Can also group inside & use .color_var\n#' FANG %>%\n#'     mutate(year = year(date)) %>%\n#'     plot_time_series(date, adjusted,\n#'                      .facet_vars   = c(symbol, year), # add groups/facets\n#'                      .color_var    = year,            # color by year\n#'                      .facet_ncol   = 4,\n#'                      .facet_scales = \"free\",\n#'                      .interactive  = FALSE)\n#'\n#' # Can apply transformations to .value or .color_var\n#' # - .value = log(adjusted)\n#' # - .color_var = year(date)\n#' FANG %>%\n#'     plot_time_series(date, log(adjusted),\n#'                      .color_var    = year(date),\n#'                      .facet_vars   = contains(\"symbol\"),\n#'                      .facet_ncol   = 2,\n#'                      .facet_scales = \"free\",\n#'                      .y_lab        = \"Log Scale\",\n#'                      .interactive  = FALSE)\n#'\n#'\n#'\n#' @export\nplot_time_series <- function(.data, .date_var, .value, .color_var = NULL,\n\n                             .facet_vars = NULL,\n                             .facet_ncol = 1, .facet_scales = \"free_y\",\n                             .facet_dir = \"h\",\n                             .facet_collapse = TRUE, .facet_collapse_sep = \" \",\n\n                             .line_color = \"#2c3e50\", .line_size = 0.5,\n                             .line_type = 1, .line_alpha = 1,\n                             .y_intercept = NULL, .y_intercept_color = \"#2c3e50\",\n\n                             .smooth = TRUE, .smooth_period = \"auto\",\n                             .smooth_message = FALSE,\n                             .smooth_span = NULL, .smooth_degree = 2,\n                             .smooth_color = \"#3366FF\", .smooth_size = 1, .smooth_alpha = 1,\n\n                             .legend_show = TRUE,\n\n                             .title = \"Time Series Plot\", .x_lab = \"\", .y_lab = \"\",\n                             .color_lab = \"Legend\",\n\n                             .interactive = TRUE, .plotly_slider = FALSE) {\n\n    # Tidyeval Setup\n    date_var_expr  <- rlang::enquo(.date_var)\n    value_expr     <- rlang::enquo(.value)\n    color_var_expr <- rlang::enquo(.color_var)\n\n    # Checks\n    if (!is.data.frame(.data)) {\n        stop(call. = FALSE, \"plot_time_series(.data) is not a data-frame or tibble. Please supply a data.frame or tibble.\")\n    }\n    if (rlang::quo_is_missing(date_var_expr)) {\n        stop(call. = FALSE, \"plot_time_series(.date_var) is missing. Please supply a date or date-time column.\")\n    }\n    if (rlang::quo_is_missing(value_expr)) {\n        stop(call. = FALSE, \"plot_time_series(.value) is missing. Please a numeric column.\")\n    }\n\n\n    UseMethod(\"plot_time_series\", .data)\n}\n\n#' @export\nplot_time_series.data.frame <- function(.data, .date_var, .value, .color_var = NULL,\n                                        .facet_vars = NULL,\n                                        .facet_ncol = 1,  .facet_scales = \"free_y\",\n                                        .facet_dir = \"h\",\n                                        .facet_collapse = TRUE, .facet_collapse_sep = \" \",\n                                        .line_color = \"#2c3e50\", .line_size = 0.5,\n                                        .line_type = 1, .line_alpha = 1,\n                                        .y_intercept = NULL, .y_intercept_color = \"#2c3e50\",\n\n                                        .smooth = TRUE, .smooth_period = \"auto\",\n                                        .smooth_message = FALSE,\n                                        .smooth_span = NULL, .smooth_degree = 2,\n                                        .smooth_color = \"#3366FF\", .smooth_size = 1, .smooth_alpha = 1,\n\n                                        .legend_show = TRUE,\n\n                                        .title = \"Time Series Plot\", .x_lab = \"\", .y_lab = \"\",\n                                        .color_lab = \"Legend\",\n\n                                        .interactive = TRUE, .plotly_slider = FALSE) {\n\n\n    # Tidyeval Setup\n    date_var_expr  <- rlang::enquo(.date_var)\n    value_expr     <- rlang::enquo(.value)\n    facets_expr    <- rlang::enquo(.facet_vars)\n    color_var_expr <- rlang::enquo(.color_var)\n\n    # Facet Names\n    facet_names <- .data %>% dplyr::ungroup() %>% dplyr::select(!!! facets_expr) %>% colnames()\n    facets_expr <- rlang::syms(facet_names)\n\n\n    # ---- DATA SETUP ----\n\n    # Evaluate Formula\n    data_formatted <- tibble::as_tibble(.data) %>%\n        dplyr::group_by(!!! facets_expr) %>%\n        dplyr::mutate(.value_mod = !! value_expr) %>%\n        dplyr::ungroup()\n\n    # Color setup\n    if (rlang::quo_is_missing(color_var_expr)) color_var_expr <- enquo(NULL)\n\n    if (!rlang::quo_is_null(color_var_expr)) {\n\n        data_formatted <- data_formatted %>%\n            dplyr::group_by(!!! facets_expr) %>%\n            dplyr::mutate(.color_mod = (!! color_var_expr)) %>%\n            dplyr::ungroup() %>%\n            dplyr::mutate(.color_mod = forcats::as_factor(.color_mod))\n    }\n\n    # Facet setup\n    facet_names <- data_formatted %>% dplyr::select(!!! facets_expr) %>% colnames()\n\n    if (length(facet_names) > 0) {\n        if (.facet_collapse) {\n\n            data_formatted <- data_formatted %>%\n                dplyr::ungroup() %>%\n                dplyr::mutate(.facets_collapsed = stringr::str_c(!!! rlang::syms(facet_names),\n                                                                sep = .facet_collapse_sep)) %>%\n                dplyr::mutate(.facets_collapsed = forcats::as_factor(.facets_collapsed)) %>%\n                dplyr::group_by(.facets_collapsed)\n\n            facet_names <- \".facets_collapsed\"\n\n        } else {\n            data_formatted <- data_formatted %>%\n                dplyr::group_by(!!! rlang::syms(facet_names))\n        }\n    }\n\n    # Smooth calculation\n    if (.smooth) {\n\n        # Handle Groups\n        group_names   <- dplyr::group_vars(data_formatted)\n        if (!rlang::quo_is_null(color_var_expr)) {\n            # If color applied, add as group variable\n            group_names <- c(group_names, \".color_mod\")\n        }\n\n        if (length(group_names) > 0) {\n            data_formatted <- data_formatted %>%\n                dplyr::ungroup() %>%\n                dplyr::group_by(!!! rlang::syms(group_names))\n        }\n\n        # Apply smoother\n        data_formatted <- data_formatted %>%\n            dplyr::mutate(.value_smooth = auto_smooth(\n                idx                   = !! date_var_expr,\n                x                     = .value_mod,\n                smooth_period         = .smooth_period,\n                smooth_span           = .smooth_span,\n                smooth_degree         = .smooth_degree,\n                smooth_message        = .smooth_message)\n            ) %>%\n            dplyr::ungroup()\n    }\n\n    # If .value exists, remove it\n    if (any(\".value\" %in% names(data_formatted))) {\n        data_formatted <- data_formatted %>%\n            dplyr::select(-.value)\n    }\n\n\n    # ---- PLOT SETUP ----\n\n    g <- data_formatted %>%\n        dplyr::rename(.value = .value_mod) %>%\n        ggplot2::ggplot(ggplot2::aes(!! date_var_expr, .value))\n\n    # Add line\n    if (rlang::quo_is_null(color_var_expr)) {\n        g <- g +\n            ggplot2::geom_line(\n                color    = .line_color,\n                size     = .line_size,\n                linetype = .line_type,\n                alpha    = .line_alpha\n            )\n\n    } else {\n        g <- g +\n            ggplot2::geom_line(\n                ggplot2::aes(color = .color_mod, group = .color_mod),\n                size     = .line_size,\n                linetype = .line_type,\n                alpha    = .line_alpha\n            ) +\n            scale_color_tq()\n    }\n\n    # Add facets\n    if (length(facet_names) > 0) {\n        g <- g +\n            ggplot2::facet_wrap(\n                ggplot2::vars(!!! rlang::syms(facet_names)),\n                ncol   = .facet_ncol,\n                scales = .facet_scales,\n                dir    = .facet_dir\n            )\n    }\n\n    # Add a smoother\n    if (.smooth) {\n        if (rlang::quo_is_null(color_var_expr)) {\n            g <- g +\n                ggplot2::geom_line(\n                    ggplot2::aes(y = .value_smooth),\n                    color = .smooth_color,\n                    size  = .smooth_size,\n                    alpha = .smooth_alpha)\n\n        } else {\n            g <- g +\n                ggplot2::geom_line(\n                    ggplot2::aes(y = .value_smooth, group = .color_mod),\n                    color = .smooth_color,\n                    size  = .smooth_size,\n                    alpha = .smooth_alpha\n                )\n        }\n\n    }\n\n    # Add a Y-Intercept if desired\n    if (!is.null(.y_intercept)) {\n        g <- g +\n            ggplot2::geom_hline(yintercept = .y_intercept, color = .y_intercept_color)\n    }\n\n    # Add theme & labs\n    g <- g +\n        theme_tq() +\n        ggplot2::labs(x = .x_lab, y = .y_lab, title = .title, color = .color_lab)\n\n    # Show Legend?\n    if (!.legend_show) {\n        g <- g +\n            ggplot2::theme(legend.position = \"none\")\n    }\n\n    if (.interactive) {\n\n        p <- plotly::ggplotly(g, dynamicTicks = TRUE)\n\n        if (.plotly_slider) {\n            p <- p %>%\n                plotly::layout(\n                    xaxis = list(\n                        rangeslider = list(type = \"date\")\n                    )\n                )\n        }\n\n        return(p)\n    } else {\n        return(g)\n    }\n}\n\n#' @export\nplot_time_series.grouped_df <- function(.data, .date_var, .value, .color_var = NULL,\n                                        .facet_vars = NULL,\n                                        .facet_ncol = 1,  .facet_scales = \"free_y\", .facet_dir = \"h\",\n                                        .facet_collapse = TRUE, .facet_collapse_sep = \" \",\n                                        .line_color = \"#2c3e50\", .line_size = 0.5,\n                                        .line_type = 1, .line_alpha = 1,\n                                        .y_intercept = NULL, .y_intercept_color = \"#2c3e50\",\n\n                                        .smooth = TRUE, .smooth_period = \"auto\",\n                                        .smooth_message = FALSE,\n                                        .smooth_span = NULL, .smooth_degree = 2,\n                                        .smooth_color = \"#3366FF\", .smooth_size = 1, .smooth_alpha = 1,\n\n                                        .legend_show = TRUE,\n\n                                        .title = \"Time Series Plot\", .x_lab = \"\", .y_lab = \"\",\n                                        .color_lab = \"Legend\",\n\n                                        .interactive = TRUE, .plotly_slider = FALSE) {\n\n    # Tidy Eval Setup\n    group_names   <- dplyr::group_vars(.data)\n    value_expr    <- rlang::enquo(.value)\n    facets_expr   <- rlang::enquos(.facet_vars)\n\n    # Checks\n    facet_names <- .data %>% dplyr::ungroup() %>% dplyr::select(!!! facets_expr) %>% colnames()\n    if (length(facet_names) > 0) message(\"plot_time_series(...): Groups are previously detected. Grouping by: \",\n                                          stringr::str_c(group_names, collapse = \", \"))\n\n    # ---- DATA SETUP ----\n\n    # Ungroup Data\n    data_formatted <- .data %>% dplyr::ungroup()\n\n    # ---- PLOT SETUP ----\n\n    plot_time_series(\n        .data              = data_formatted,\n        .date_var          = !! rlang::enquo(.date_var),\n        .value             = !! rlang::enquo(.value),\n        .color_var         = !! rlang::enquo(.color_var),\n\n        # ...\n        .facet_vars        = !! enquo(group_names),\n\n        .facet_ncol            = .facet_ncol,\n        .facet_scales          = .facet_scales,\n        .facet_dir             = .facet_dir,\n        .facet_collapse        = .facet_collapse,\n        .facet_collapse_sep    = .facet_collapse_sep,\n        .line_color            = .line_color,\n        .line_size             = .line_size,\n        .line_type             = .line_type,\n        .line_alpha            = .line_alpha,\n        .y_intercept           = .y_intercept,\n        .y_intercept_color     = .y_intercept_color,\n\n        .smooth                = .smooth,\n        .smooth_period         = .smooth_period,\n        .smooth_message        = .smooth_message,\n        .smooth_span           = .smooth_span,\n        .smooth_degree         = .smooth_degree,\n        .smooth_color          = .smooth_color,\n        .smooth_size           = .smooth_size,\n        .smooth_alpha          = .smooth_alpha,\n\n        .legend_show           = .legend_show,\n\n        .title                 = .title,\n        .x_lab                 = .x_lab,\n        .y_lab                 = .y_lab,\n        .interactive           = .interactive,\n        .plotly_slider         = .plotly_slider\n    )\n\n\n}\n\n\n# UTILS ----\n\n# A wrapper for smooth_vec() that handles changes in grouped idx's\nauto_smooth <- function(idx, x,\n                        smooth_period,\n                        smooth_span,\n                        smooth_degree,\n                        smooth_message) {\n\n    if (length(idx) < 2) {\n        return(x)\n    }\n\n    if (all(c(is.null(smooth_span), is.numeric(idx)))) {\n        # Numeric index\n        smooth_span <- 0.75\n    }\n\n    if (all({\n        c(!is.null(smooth_period),\n          is.null(smooth_span)\n          )\n    })) {\n        # smooth_period = some value, and smooth span is NULL\n\n        if (tolower(smooth_period) == \"auto\") {\n            smooth_period <- ceiling(length(idx) * 0.75)\n        }\n\n        smooth_period <- tk_get_trend(\n            idx      = idx,\n            period   = smooth_period,\n            message  = smooth_message\n        )\n\n        smooth_span <- NULL\n    } else {\n        # smooth span overrides smooth period\n        smooth_period <- NULL\n        smooth_span   <- as.numeric(smooth_span)\n        # if (smooth_message) message(stringr::str_glue())\n    }\n\n   ret <- smooth_vec(\n       x      = x,\n       period = smooth_period,\n       span   = smooth_span,\n       degree = smooth_degree\n    )\n\n    return(ret)\n}\n\n\n#' Interactive Forecast Visualization\n#'\n#' This is a wrapper for [plot_time_series()] that generates an interactive (`plotly`) or static\n#' (`ggplot2`) plot with the forecasted data.\n#'\n#' @inheritParams plot_time_series\n#' @param .data A `tibble` that is the output of [modeltime_forecast()]\n#' @param .legend_show Logical. Whether or not to show the legend.\n#'  Can save space with long model descriptions.\n#' @param .legend_max_width Numeric. The width of truncation to apply to the legend text.\n#' @param .conf_interval_show Logical. Whether or not to include the confidence interval as a ribbon.\n#' @param .conf_interval_fill Fill color for the confidence interval\n#' @param .conf_interval_alpha Fill opacity for the confidence interval. Range (0, 1).\n#' @param ... Additional arguments passed to [plot_time_series()].\n#'\n#' @return A static `ggplot2` plot or an interactive `plotly` plot containing a forecast\n#'\n#'\n#'\n#' @examples\n#' library(tidyverse)\n#' library(lubridate)\n#' library(timetk)\n#' library(parsnip)\n#' library(rsample)\n#' library(modeltime)\n#'\n#' # Data\n#' m750 <- m4_monthly %>% filter(id == \"M750\")\n#'\n#' # Split Data 80/20\n#' splits <- initial_time_split(m750, prop = 0.9)\n#'\n#' # --- MODELS ---\n#'\n#' # Model 1: prophet ----\n#' model_fit_prophet <- prophet_reg() %>%\n#'     set_engine(engine = \"prophet\") %>%\n#'     fit(value ~ date, data = training(splits))\n#'\n#'\n#' # ---- MODELTIME TABLE ----\n#'\n#' models_tbl <- modeltime_table(\n#'     model_fit_prophet\n#' )\n#'\n#' # ---- FORECAST ----\n#'\n#' models_tbl %>%\n#'     modeltime_calibrate(new_data = testing(splits)) %>%\n#'     modeltime_forecast(\n#'         new_data    = testing(splits),\n#'         actual_data = m750\n#'     ) %>%\n#'     plot_modeltime_forecast(.interactive = FALSE)\n#'\n#' @export\nplot_modeltime_forecast <- function(.data,\n                                    .conf_interval_show = TRUE,\n                                    .conf_interval_fill = \"grey20\",\n                                    .conf_interval_alpha = 0.20,\n                                    .smooth = FALSE,\n                                    .legend_show = TRUE,\n                                    .legend_max_width = 40,\n                                    .title = \"Forecast Plot\", .x_lab = \"\", .y_lab = \"\",\n                                    .color_lab = \"Legend\",\n                                    .interactive = TRUE, .plotly_slider = FALSE,\n                                    ...) {\n\n    # Checks\n    if (!inherits(.data, \"data.frame\")) {\n        glubort(\"No method for {class(.data)[1]}. Expecting the output of 'modeltime_forecast()'.\")\n    }\n\n    if (!all(c(\".model_id\", \".model_desc\", \".key\", \".index\", \".value\") %in% names(.data))) {\n        rlang::abort(\"Expecting the following names to be in the data frame: .key, .index, .value. Try using 'modeltime_forecast()' to return a data frame in the appropriate structure.\")\n    }\n\n    if (.conf_interval_show) {\n        if (!all(c(\".conf_lo\", \".conf_hi\") %in% names(.data))) {\n            .conf_interval_show <- FALSE\n            rlang::warn(\"Expecting the following names to be in the data frame: .conf_hi, .conf_lo. \\nProceeding with '.conf_interval_show = FALSE' to visualize the forecast without confidence intervals.\\nAlternatively, try using `modeltime_calibrate()` before forecasting to add confidence intervals.\")\n        }\n    }\n\n\n    g <- plot_modeltime_forecast_multi(\n        .data                  = .data,\n        .conf_interval_show    = .conf_interval_show,\n        .conf_interval_fill    = .conf_interval_fill,\n        .conf_interval_alpha   = .conf_interval_alpha,\n        .smooth                = .smooth,\n        .legend_show           = .legend_show,\n        .legend_max_width      = .legend_max_width,\n        .title                 = .title,\n        .x_lab                 = .x_lab,\n        .y_lab                 = .y_lab,\n        .color_lab             = .color_lab,\n        .interactive           = .interactive,\n        .plotly_slider         = .plotly_slider,\n        ...\n    )\n\n\n    # INTERACTIVE\n\n    if (.interactive) {\n\n        p <- plotly::ggplotly(g, dynamicTicks = TRUE)\n\n        if (.plotly_slider) {\n            p <- p %>%\n                plotly::layout(\n                    xaxis = list(\n                        rangeslider = list(type = \"date\")\n                    )\n                )\n        }\n\n        return(p)\n    } else {\n        return(g)\n    }\n\n}\n\n\n\nplot_modeltime_forecast_multi <- function(.data,\n                                          .conf_interval_show = TRUE,\n                                          .conf_interval_fill = \"grey20\",\n                                          .conf_interval_alpha = 0.20,\n                                          .smooth = FALSE,\n                                          .legend_show = TRUE,\n                                          .legend_max_width = 40,\n                                          .title = \"Forecast Plot\", .x_lab = \"\", .y_lab = \"\",\n                                          .color_lab = \"Legend\",\n                                          .interactive = TRUE, .plotly_slider = FALSE,\n                                          ...) {\n\n\n    # Data prep\n    data_prepared <- .data %>%\n        dplyr::arrange(.key, .model_id, .index) %>%\n        # dplyr::ungroup() %>%\n        dplyr::mutate(.model_desc = ifelse(!is.na(.model_id), stringr::str_c(.model_id, \"_\", .model_desc), .model_desc)) %>%\n        dplyr::mutate(.model_desc = ifelse(is.na(.value), stringr::str_c(\"(ERROR) \", .model_desc), .model_desc)) %>%\n        dplyr::mutate(.model_desc = .model_desc %>% stringr::str_trunc(width = .legend_max_width)) %>%\n        dplyr::mutate(.model_desc = forcats::as_factor(.model_desc))\n\n    # Isolate just the forecast data\n    data_prepared_forecast_only <- data_prepared %>%\n        dplyr::filter(.model_desc != \"ACTUAL\")\n\n    # Check for only 1 forecast\n    #  if 1 forecast, n_forecast_timestamps == 1\n    n_forecast_timestamps <- data_prepared_forecast_only %>%\n        dplyr::ungroup() %>%\n        dplyr::pull(.index) %>%\n        unique() %>%\n        length()\n\n    # Make the plot\n    #g <- timetk::plot_time_series(\n    g <- plot_time_series(\n        .data         = data_prepared,\n        .date_var     = .index,\n        .value        = .value,\n        .color_var    = .model_desc,\n\n        .smooth       = .smooth,\n\n        .title        = .title,\n        .x_lab        = .x_lab,\n        .y_lab        = .y_lab,\n        .color_lab    = .color_lab,\n        .interactive  = FALSE\n        ,\n        ...\n    )\n\n    # If forecast timestamps are 1, add geom_point()\n    if (n_forecast_timestamps == 1) {\n        g <- g +\n            ggplot2::geom_point(\n                ggplot2::aes(color = .model_desc),\n                data = . %>% dplyr::filter(.model_desc != \"ACTUAL\")\n            )\n    }\n\n    # Add ribbon\n    if (.conf_interval_show) {\n\n        if (n_forecast_timestamps > 1) {\n\n            # Add ribbon\n            g <- g +\n                ggplot2::geom_ribbon(\n                    ggplot2::aes(\n                        ymin = .conf_lo,\n                        ymax = .conf_hi,\n                        # group = .model_desc\n                        # ,\n                        color = .model_desc\n                    ),\n                    fill     = .conf_interval_fill,\n                    alpha    = .conf_interval_alpha,\n                    # color    = .conf_interval_fill,\n                    # na.rm    = TRUE, # causes error\n                    # data = . %>% dplyr::filter(.model_desc != \"ACTUAL\"),\n                    linetype = 0\n                )\n\n\n            # Reorder Ribbon to 1st level\n            layers_start <- g$layers\n\n            g$layers[[1]] <- layers_start[[2]]\n            g$layers[[2]] <- layers_start[[1]]\n\n        }\n\n    }\n\n    if (!.legend_show) {\n        g <- g +\n            ggplot2::theme(legend.position = \"none\")\n    }\n\n    return(g)\n\n}\n# tidyquant functions copied to remove dependency on tidyquant\n\n#' @importFrom ggplot2 %+replace%\n\ntheme_tq <- function(base_size = 11, base_family = \"\") {\n\n    # Tidyquant colors\n    blue  <- \"#2c3e50\"\n    green <- \"#18BC9C\"\n    white <- \"#FFFFFF\"\n    grey  <- \"grey80\"\n\n    # Starts with theme_grey and then modify some parts\n    ggplot2::theme_grey(base_size = base_size, base_family = base_family) %+replace%\n        ggplot2::theme(\n\n            # Base Inherited Elements\n            line               =  ggplot2::element_line(colour = blue, size = 0.5, linetype = 1,\n                                                        lineend = \"butt\"),\n            rect               =  ggplot2::element_rect(fill = white, colour = blue,\n                                                        size = 0.5, linetype = 1),\n            text               =  ggplot2::element_text(family = base_family, face = \"plain\",\n                                                        colour = blue, size = base_size,\n                                                        lineheight = 0.9, hjust = 0.5, vjust = 0.5, angle = 0,\n                                                        margin = ggplot2::margin(), debug = FALSE),\n\n            # Axes\n            axis.line          = ggplot2::element_blank(),\n            axis.text          = ggplot2::element_text(size = ggplot2::rel(0.8)),\n            axis.ticks         = ggplot2::element_line(color = grey, size = ggplot2::rel(1/3)),\n            axis.title         = ggplot2::element_text(size = ggplot2::rel(1.0)),\n\n            # Panel\n            panel.background   = ggplot2::element_rect(fill = white, color = NA),\n            panel.border       = ggplot2::element_rect(fill = NA, size = ggplot2::rel(1/2), color = blue),\n            panel.grid.major   = ggplot2::element_line(color = grey, size = ggplot2::rel(1/3)),\n            panel.grid.minor   = ggplot2::element_line(color = grey, size = ggplot2::rel(1/3)),\n            panel.grid.minor.x = ggplot2::element_blank(),\n            panel.spacing      = ggplot2::unit(.75, \"cm\"),\n\n            # Legend\n            legend.key         = ggplot2::element_rect(fill = white, color = NA),\n            legend.position    = \"bottom\",\n\n            # Strip (Used with multiple panels)\n            strip.background   = ggplot2::element_rect(fill = blue, color = blue),\n            strip.text         = ggplot2::element_text(color = white, size = ggplot2::rel(0.8), margin = ggplot2::margin(t = 5, b = 5)),\n\n            # Plot\n            plot.title         = ggplot2::element_text(size = ggplot2::rel(1.2), hjust = 0,\n                                                       margin = ggplot2::margin(t = 0, r = 0, b = 4, l = 0, unit = \"pt\")),\n            plot.subtitle      = ggplot2::element_text(size = ggplot2::rel(0.9), hjust = 0,\n                                                       margin = ggplot2::margin(t = 0, r = 0, b = 3, l = 0, unit = \"pt\")),\n\n            # Complete theme\n            complete = TRUE\n        )\n}\n\ntheme_tq_dark <- function(base_size = 11, base_family = \"\") {\n\n    # Tidyquant colors\n    blue  <- \"#2c3e50\"\n    green <- \"#18BC9C\"\n    white <- \"#FFFFFF\"\n    grey  <- \"grey50\"\n\n    # Starts with theme_tq and then invert some colors\n    theme_tq(base_size = base_size, base_family = base_family) %+replace%\n        ggplot2::theme(\n\n            # Axes\n            axis.ticks         = ggplot2::element_line(color = blue, size = ggplot2::rel(1/3)),\n\n            # Panel\n            panel.background   = ggplot2::element_rect(fill = grey, color = NA),\n            panel.grid.major   = ggplot2::element_line(color = white, size = ggplot2::rel(1/3)),\n            panel.grid.minor   = ggplot2::element_line(color = white, size = ggplot2::rel(1/3)),\n\n            # Complete theme\n            complete = TRUE\n        )\n}\n\ntheme_tq_green <- function(base_size = 11, base_family = \"\") {\n\n    # Tidyquant colors\n    blue  <- \"#2c3e50\"\n    green <- \"#18BC9C\"\n    white <- \"#FFFFFF\"\n    grey  <- \"grey80\"\n\n    # Starts with theme_tq and then invert some colors\n    theme_tq(base_size = base_size, base_family = base_family) %+replace%\n        ggplot2::theme(\n\n            # Axes\n            axis.ticks         = ggplot2::element_line(color = blue, size = ggplot2::rel(1/3)),\n\n            # Panel\n            panel.background   = ggplot2::element_rect(fill = green, color = NA),\n            panel.grid.major   = ggplot2::element_line(color = white, size = ggplot2::rel(1/3)),\n            panel.grid.minor   = ggplot2::element_line(color = white, size = ggplot2::rel(1/3)),\n\n            # Complete theme\n            complete = TRUE\n        )\n}\n\nscale_color_tq <- function(..., theme = \"light\") {\n\n    pal <- switch(theme,\n                  \"light\" = unname(palette_light()) %>% rep(100),\n                  \"dark\"  = unname(palette_dark()) %>% rep(100),\n                  \"green\" = unname(palette_green() %>% rep(100))\n    )\n\n    ggplot2::scale_color_manual(values = pal)\n}\n\npalette_light <- function() {\n    c(\n        blue         = \"#2c3e50\", # blue\n        red          = \"#e31a1c\", # red\n        green        = \"#18BC9C\", # green\n        yellow       = \"#CCBE93\", # yellow\n        steel_blue   = \"#a6cee3\", # steel_blue\n        navy_blue    = \"#1f78b4\", # navy_blue\n        light_green  = \"#b2df8a\", # light_green\n        pink         = \"#fb9a99\", # pink\n        light_orange = \"#fdbf6f\", # light_orange\n        orange       = \"#ff7f00\", # orange\n        light_purple = \"#cab2d6\", # light_purple\n        purple       = \"#6a3d9a\"  # purple\n    ) %>% toupper()\n}\n\npalette_dark <- function() {\n    # Brighter version of palette_light\n    c(\n        blue         = \"#0055AA\", # blue\n        red          = \"#C40003\", # red\n        green        = \"#00C19B\", # green\n        yellow       = \"#EAC862\", # yellow\n        steel_blue   = \"#7FD2FF\", # steel_blue\n        navy_blue    = \"#007ED3\", # navy_blue\n        light_green  = \"#b2df8a\", # light_green\n        pink         = \"#FFACAA\", # pink\n        light_orange = \"#FF9D1E\", # light_orange\n        lime_green   = \"#C3EF00\", # lime_green\n        light_purple = \"#cab2d6\", # light_purple\n        purple       = \"#894FC6\"  # purple\n    ) %>% toupper()\n}\n\npalette_green <- function() {\n    # Green compatible version of palette_light\n    c(\n        blue         = \"#0055AA\", # blue\n        red          = \"#C40003\", # red\n        yellow       = \"#EAC862\", # yellow\n        steel_blue   = \"#7FD2FF\", # steel_blue\n        navy_blue    = \"#007ED3\", # navy_blue\n        creme        = \"#F6F4F3\", # creme\n        pink         = \"#FFACAA\", # pink\n        light_orange = \"#FF9D1E\", # light_orange\n        lime_green   = \"#C3EF00\", # lime_green\n        light_purple = \"#cab2d6\", # light_purple\n        purple       = \"#894FC6\", # purple\n        brown        = \"#592E2E\"  # brown\n    ) %>% toupper()\n}\n\npalette_light <- function() {\n    c(\n        blue         = \"#2c3e50\", # blue\n        red          = \"#e31a1c\", # red\n        green        = \"#18BC9C\", # green\n        yellow       = \"#CCBE93\", # yellow\n        steel_blue   = \"#a6cee3\", # steel_blue\n        navy_blue    = \"#1f78b4\", # navy_blue\n        light_green  = \"#b2df8a\", # light_green\n        pink         = \"#fb9a99\", # pink\n        light_orange = \"#fdbf6f\", # light_orange\n        orange       = \"#ff7f00\", # orange\n        light_purple = \"#cab2d6\", # light_purple\n        purple       = \"#6a3d9a\"  # purple\n    ) %>% toupper()\n}\n\n#-- Default values (mandatory) ----\nconf_interval_show <- TRUE\nconf_interval_alpha <- 0.2\nsmooth <- FALSE\nlegend_show <- TRUE\nlegend_max_width <- 40\ntitle <- \"Forecast Plot\"\nx_lab <- \"\"\ny_lab <- \"\"\nplotly_slider <- FALSE\n\n\nconf_interval_fill <- \"#ec8fca\"\n#-----------------------------------\n\nif(exists(\"settings_variable_params_conf_interval_show_bool\")){\n    conf_interval_show <- as.logical(settings_variable_params_conf_interval_show_bool)\n}\n\nif(exists(\"settings_variable_params_conf_interval_alpha\")){\n    conf_interval_alpha <- as.numeric(settings_variable_params_conf_interval_alpha)\n}\n\nif(exists(\"settings_variable_params_smooth_bool\")){\n    smooth <- as.logical(settings_variable_params_smooth_bool)\n}\n\nif(exists(\"settings_variable_params_legend_show_bool\")){\n    legend_show <- as.logical(settings_variable_params_legend_show_bool)\n}\n\nif(exists(\"settings_variable_params_legend_max_width\")){\n    legend_max_width <- as.numeric(settings_variable_params_legend_max_width)\n}\n\nif(exists(\"settings_variable_params_title_str\")){\n    title <- as.character(settings_variable_params_title_str)\n}\n\nif(exists(\"settings_variable_params_x_lab_str\")){\n    x_lab <- as.character(settings_variable_params_x_lab_str)\n}\n\nif(exists(\"settings_variable_params_y_lab_str\")){\n    y_lab <- as.character(settings_variable_params_y_lab_str)\n}\n\nif(exists(\"settings_variable_params_plotly_slider_bool\")){\n    plotly_slider <- as.logical(settings_variable_params_plotly_slider_bool)\n}\n\nif(exists(\"settings_variable_params_conf_interval_fill_picker\")){\n    conf_interval_fill <- as.character(settings_variable_params_conf_interval_fill_picker)\n}\n\n\nis_valid_plot <- FALSE\n\nif (exists('index') & exists('value')) {\n    \n    index_var_name <- names(index)\n    value_var_name <- names(value)\n    \n    dataset <- data.frame(\n        .index = as.POSIXct(index[[index_var_name]]),\n        .value = value[[value_var_name]]\n    )\n    \n    \n    if (exists('value_type')) {\n        \n        value_type_var_name   <- names(value_type)\n        \n        dataset <- cbind(dataset,\n                         .key = value_type[[value_type_var_name]])\n        \n    } else {\n        value_type_var_name   <- NULL\n    }\n    \n    \n    if (exists('conf_lo') & exists('conf_hi')) {\n        \n        conf_lo_var_name   <- names(conf_lo)\n        conf_hi_var_name   <- names(conf_hi)\n        \n        dataset <- cbind(dataset,\n                         .conf_lo = conf_lo[[conf_lo_var_name]],\n                         .conf_hi = conf_hi[[conf_hi_var_name]])\n        \n    } else {\n        conf_interval_show <- FALSE\n        conf_lo_var_name   <- NULL\n        conf_hi_var_name   <- NULL\n    }\n    \n    if (exists('model_id') & exists('model_descr')) {\n        \n        model_id_var_name   <- names(model_id)\n        model_descr_var_name   <- names(model_descr)\n        \n        dataset <- cbind(dataset,\n                         .model_id = model_id[[model_id_var_name]],\n                         .model_descr = model_descr[[model_descr_var_name]])\n        \n    } else {\n        model_id_var_name   <- NULL\n        model_descr_var_name   <- NULL\n    }\n    \n    is_valid_plot <- TRUE\n}\n\n\nif (is_valid_plot) {\n    p <- dataset %>%\n        mutate(\n            .key = if(is.null(value_type_var_name)) ifelse( is.null(conf_lo_var_name),\n                                                            \"actual\",\n                                                            ifelse(is.na(conf_lo), \"actual\", \"prediction\")\n            ) else .key\n        ) %>%\n        mutate(\n            .model_id   = if(is.null(model_id_var_name)) \n                            ifelse(.key == \"actual\", NA, 1)\n                          else .model_id,\n            .model_desc = if(is.null(model_descr_var_name))\n                            ifelse(.key == \"actual\", \"ACTUAL\", \"model-1\")\n                          else .model_descr,\n        ) %>% \n        plot_modeltime_forecast(\n            .conf_interval_show = conf_interval_show,\n            .conf_interval_fill = conf_interval_fill,\n            .conf_interval_alpha = conf_interval_alpha,\n            .smooth = smooth,\n            .legend_show = legend_show,\n            .legend_max_width = legend_max_width,\n            .interactive = TRUE,\n            .title = title,\n            .x_lab = x_lab,\n            .y_lab = y_lab,\n            .plotly_slider = plotly_slider\n        )\n} else {\n    rc <- ggplot() + theme_minimal() # Empty plot\n    p <- plotly::ggplotly(rc, tooltip = c('x', 'y'))\n}\n\n\n####################################################\n\n############# Create and save widget ###############\ninternalSaveWidget(p, 'out.html');\n####################################################\n\n################ Reduce paddings ###################\nReadFullFileReplaceString('out.html', 'out.html', ',\"padding\":[0-9]*,', ',\"padding\":0,')\n####################################################\n\n"}}}],"objects":{"rcv_script":{"properties":{"provider":{"type":{"text":true}},"source":{"type":{"scripting":{"source":true}}}}},"settings_variable_params":{"displayName":"Plot Settings","properties":{"conf_interval_show_bool":{"displayName":"Show Confidence Interval","description":"Whether or not to include the confidence interval as a ribbon.","type":{"bool":true}},"conf_interval_alpha":{"displayName":"Alpha Confidence Interval","description":"Fill opacity for the confidence interval. Range (0, 1).","type":{"numeric":true}},"smooth_bool":{"displayName":"Show Trendline Smoother","description":"Logical - Whether or not to include a trendline  LOESS smoother.","type":{"bool":true}},"legend_show_bool":{"displayName":"Show Legend","description":"Logical. Whether or not to show the legend. Can save space with long model descriptions.","type":{"bool":true}},"legend_max_width":{"displayName":"Max Width of Legend Text","description":"Numeric. The width of truncation to apply to the legend text.","type":{"numeric":true}},"title_str":{"displayName":"Title","description":"Title for the plot.","type":{"text":true}},"x_lab_str":{"displayName":"X Label","description":"X-axis label for the plot.","type":{"text":true}},"y_lab_str":{"displayName":"Y Label","description":"Y-axis label for the plot.","type":{"text":true}},"plotly_slider_bool":{"displayName":"Show Plotly Slider","description":"If TRUE, returns a plotly date range slider.","type":{"bool":true}},"line_color_picker":{"displayName":"Line Color Fill","description":"Line color. Overrided if 'color_var' is specified.","type":{"fill":{"solid":{"color":true}}}},"conf_interval_fill_picker":{"displayName":"Confidence Interval Color Fill","description":"Fill color for the confidence interval.","type":{"fill":{"solid":{"color":true}}}}}}},"suppressDefaultTitle":true},"dependencies":{"cranPackages":[{"name":"ggplot2","displayName":"GG Plot 2","url":"https://cran.r-project.org/web/packages/ggplot2/index.html"},{"name":"plotly","displayName":"Plotly","url":"https://cran.r-project.org/web/packages/plotly/index.html"},{"name":"htmlwidgets","displayName":"HTML Widgets","url":"https://cran.r-project.org/web/packages/htmlwidgets/index.html"},{"name":"xml2","displayName":"xml2","url":"https://cran.r-project.org/web/packages/xml2/index.html"},{"name":"dplyr","displayName":"Dplyr","url":"https://cran.r-project.org/web/packages/dplyr/index.html"}]},"content":{"js":"var interactivetsBB3C2FD6EC3D483DB7CA402F922AA628;(()=>{\"use strict\";var e={943:(e,t,r)=>{r.d(t,{Tx:()=>i,Kq:()=>a,ME:()=>u});var n=r(787),o=0;function i(){o=0}function a(e,t){var r=[];if(e&&e.hasChildNodes()){for(var n=e.children,o=0;o<n.length;o++){var i;i=\"script\"===n.item(o).nodeName.toLowerCase()?s(n.item(o)):n.item(o).cloneNode(!0),t.appendChild(i),r.push(i)}return r}}function s(e){for(var t=document.createElement(\"script\"),r=e.attributes,n=0;n<r.length;n++)t.setAttribute(r[n].name,r[n].textContent),\"src\"===r[n].name.toLowerCase()&&(o++,t.onload=function(){o--});return t.innerHTML=e.innerHTML,t}function u(){var e=n.setInterval((function(){0===o&&(n.clearInterval(e),n.hasOwnProperty(\"HTMLWidgets\")&&n.HTMLWidgets.staticRender&&n.HTMLWidgets.staticRender())}),100)}},67:(e,t,r)=>{function n(e){return(n=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function o(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function i(e,t){return(i=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(e,t){if(t&&(\"object\"===n(t)||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return function(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}(e)}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}r.d(t,{J:()=>u});var u=function(e){!function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&i(e,t)}(u,e);var t,r,n=(t=u,r=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}(),function(){var e,n=s(t);if(r){var o=s(this).constructor;e=Reflect.construct(n,arguments,o)}else e=n.apply(this,arguments);return a(this,e)});function u(){var e;return o(this,u),(e=n.apply(this,arguments)).settings_variable_params=new c,e}return u}(r(648).U),c=function e(){o(this,e),this.conf_interval_show_bool=!0,this.conf_interval_alpha=.2,this.smooth_bool=!1,this.legend_show_bool=!0,this.legend_max_width=40,this.title_str=\"Forecast Plot\",this.x_lab_str=\"\",this.y_lab_str=\"\",this.plotly_slider_bool=!1,this.conf_interval_fill_picker=\"#ec8fca\"}},538:(e,t,r)=>{r.d(t,{u:()=>c});var n,o=r(67),i=r(943),a=r(787);function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}!function(e){e[e.Data=2]=\"Data\",e[e.Resize=4]=\"Resize\",e[e.ViewMode=8]=\"ViewMode\",e[e.Style=16]=\"Style\",e[e.ResizeEnd=32]=\"ResizeEnd\",e[e.All=62]=\"All\"}(n||(n={}));var u=[n.Resize,n.ResizeEnd,n.Resize+n.ResizeEnd],c=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),t&&t.element&&(this.rootElement=t.element),this.headNodes=[],this.bodyNodes=[]}var t,r,n;return t=e,n=[{key:\"parseSettings\",value:function(e){return o.J.parse(e)}}],(r=[{key:\"update\",value:function(t){if(t&&t.type&&t.viewport&&t.dataViews&&0!==t.dataViews.length&&t.dataViews[0]){var r=t.dataViews[0];this.settings=e.parseSettings(r);var n=null;r.scriptResult&&r.scriptResult.payloadBase64&&(n=r.scriptResult.payloadBase64),-1===u.indexOf(t.type)?n&&this.injectCodeFromPayload(n):this.onResizing(t.viewport)}}},{key:\"onResizing\",value:function(e){}},{key:\"injectCodeFromPayload\",value:function(e){if((0,i.Tx)(),e){var t=document.createElement(\"html\");try{t.innerHTML=a.atob(e)}catch(e){return}if(0===this.headNodes.length){for(;this.headNodes.length>0;){var r=this.headNodes.pop();document.head.removeChild(r)}var n=t.getElementsByTagName(\"head\");if(n&&n.length>0){var o=n[0];this.headNodes=(0,i.Kq)(o,document.head)}}for(;this.bodyNodes.length>0;){var s=this.bodyNodes.pop();this.rootElement.removeChild(s)}var u=t.getElementsByTagName(\"body\");if(u&&u.length>0){var c=u[0];this.bodyNodes=(0,i.Kq)(c,this.rootElement)}(0,i.ME)()}}},{key:\"enumerateObjectInstances\",value:function(e){return o.J.enumerateObjectInstances(this.settings||o.J.getDefault(),e)}}])&&s(t.prototype,r),n&&s(t,n),e}()},599:(e,t,r)=>{function n(e,t,r){if(!e)return r;var n=e[t];return void 0===n?r:n}r.d(t,{N:()=>n})},110:(e,t,r)=>{r.d(t,{d9:()=>i});var n=r(599);function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function i(e,t,r){var i=function(e,t,r){return e?n.N(e[t.objectName],t.propertyName,r):r}(e,t,r);return i&&i.solid?i.solid.color:null==i||\"object\"===o(i)&&!i.solid?r:i}},648:(e,t,r)=>{r.d(t,{U:()=>i});var n=r(110);function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var i=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e)}var t,r,i;return t=e,i=[{key:\"getDefault\",value:function(){return new this}},{key:\"createPropertyIdentifier\",value:function(e,t){return{objectName:e,propertyName:t}}},{key:\"parse\",value:function(e){var t,r=this.getDefault();if(!e||!e.metadata||!e.metadata.objects)return r;for(var o in t=r.getProperties())for(var i in t[o]){var a=r[o][i];r[o][i]=n.d9(e.metadata.objects,t[o][i],a)}return r}},{key:\"isPropertyEnumerable\",value:function(t){return!e.InnumerablePropertyPrefix.test(t)}},{key:\"enumerateObjectInstances\",value:function(e,t){var r=e&&e[t.objectName];if(!r)return[];var n={objectName:t.objectName,selector:null,properties:{}};for(var o in r)r.hasOwnProperty(o)&&(n.properties[o]=r[o]);return{instances:[n]}}}],(r=[{key:\"getProperties\",value:function(){var t=this,r={};return Object.keys(this).forEach((function(n){if(e.isPropertyEnumerable(n)){var o=Object.keys(t[n]);r[n]={},o.forEach((function(t){e.isPropertyEnumerable(n)&&(r[n][t]=e.createPropertyIdentifier(n,t))}))}})),r}}])&&o(t.prototype,r),i&&o(t,i),e}();i.InnumerablePropertyPrefix=/^_/},787:e=>{e.exports=Function(\"return this\")()}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})};var n={};(()=>{r.r(n),r.d(n,{default:()=>i});var e=r(538),t=r(787).powerbi,o={name:\"interactivetsBB3C2FD6EC3D483DB7CA402F922AA628\",displayName:\"Interactive Time-Series Plot\",class:\"Visual\",apiVersion:\"3.8.0\",create:function(t){if(e.u)return new e.u(t);throw\"Visual instance not found\"},createModalDialog:function(e,t,r){var n=globalThis.dialogRegistry;e in n&&new n[e](t,r)},custom:!0};void 0!==t&&(t.visuals=t.visuals||{},t.visuals.plugins=t.visuals.plugins||{},t.visuals.plugins.interactivetsBB3C2FD6EC3D483DB7CA402F922AA628=o);const i=o})(),interactivetsBB3C2FD6EC3D483DB7CA402F922AA628=n})();\n//# sourceMappingURL=visual.js.map","css":"","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALXSURBVDhPnZRrSJNhFMff17nLuzHT5lxeunifUWsllmVpmYZdKNJwdkFICgohrC9RkMSqT1F9EoKC6kMFEVhoSLlc6ax0urIiwWliRlTqdDXnytn6n73TNLxM//Db85zznP15z/a8h2V47QAtoNsbTaE9+hQBlu4NazeWhasierC3gtp8zfEROicF+LgATlNiBmVIxJLfPjNSPNh97+2VcD7kzXKBBhSBxWA66UIVSrNv71V55dJjLxoW6WGaDgRkmAcGgR3kg0mFdoVYcuNjEpv5DMM0Nkdpbf3cqtgYG7WuBnlkuJfOwFVwEUylzRwntStDw2wU9PZJ5e9bVQeSEnvuqJSOAW8FwwSTob/SKce1+/R5bGGQ/FfrutWfmnwpr/wyRLtiLLsSYtUWip+ZotOdQ8Ko7E3tdyke1ZBrSOzvE+ZIpbLv80MU9s6ukPD2j4q85BVfbswLcjnp0OPxsJYW85oqQ8VZfw11YaGqJpcrUFj3csmhiAU/azTLvrbRQUenNbry8YOT7Z3WJLfbvXVGQ7QrZVl2W2Kc2lJlSCgQCP64tmRaK/psvcFPjFUHm1vM+9HqGZSm3S81N44ZBqnUMVknTPQm/K/tMqns85t3K7X9A5wmI+3DzVdNxhyjyXBqwN5fjfMkGN0GHioOpI8AgUikiE7dhy3dxWLKjZOO8STbrR2K/IWRj+rNltqSYfdwDfJamHTxJf/kfZcFgZJ6LjiyLbXw1k6ERYbL6x9SHu3KR0aivg06ikUSrjxAJGp8jXQJjOrofDKNtezo7aDBcBRcR+txlHM6C3QOxxFOJDb2wuwwUinTmZH4acOyRvz3VFgKs3NYydiEC5EtFLaWyWTXzsPoB5XOpNHxRb8JDJhSCmC6CYuWZV2V1Zey6D2dtchQz29nLfrecn478QnloMEbzU4FIASUA/3ovaM5SONJNgcSAAdoCk2YlXNVGcjktwzzF8X+8K4AQUulAAAAAElFTkSuQmCC"},"visualEntryPoint":"","toolsVersion":null}